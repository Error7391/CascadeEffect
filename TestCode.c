#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     colorR,         sensorNone)
#pragma config(Sensor, S3,     colorL,         sensorNone)
#pragma config(Sensor, S4,     irSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,          hook,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorL,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     motorR,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    liftLow,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    liftHigh,             tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    shoulder,             tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    elbow,                tServoStandard)
#pragma config(Servo,  srvo_S1_C2_5,    collector,            tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_6,    trapDoor,             tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#define COMPETITION
//#define DEBUG
#define TEST_ARM 0
#define RAMP 1

#ifdef COMPETITION
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#endif

#include "7391RobotDriver.c" //Include file of Robot Drivers.
#include "7391AutoUtils.c" //Include file of Autonomous Utilities.

#include "ArmDriver.c" //Include file of Robot Drivers.

const int TestHook = 0;
const int TestHardware = 0;
const int TestPositions = 1;

TArmState tas;

const int loc = RAMP;
//int loc = ZONE;
const int color = BLUECOLOR;
//int color = BLUECOLOR;
//const int DELAY = 10; //seconds
const int DELAY = 0;

enum centerGoalPos
{
	  CENTER_GOAL_POS1_0DEG, //kickstand straight ahead
	  CENTER_GOAL_POS2_45DEG, //rotated 45 deg to the right
	  CENTER_GOAL_POS3_90DEG   //rotated 90 deg to the right
};

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	// Place code here to sinitialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
	char * sFileName = "debug.txt";
	short nFileSize =10000;

	eraseDisplay();
	nxtDisplayTextLine(0, "Autonomous Period");

	driveInit();
	armInit(tas);
  //Does armInit need 5 sec wait????

	wait1Msec(10);

	return;
}
//////////////////////////////////////////////////////////////////////////////////////////////
//Autonomous Period

//-by Arjun Verma (FTC Team Error 7391)



//(POSITION 1 - perpendicular)

//(POSITION 2 - 45 degrees right of POS 1)

//(POSITION 3 - 90 degrees right of POS 1)

//RAMP MODE

//Get off ramp
//Find optimal position to detect IR beacon
	//if IR beacon is detected at position one then do:
		//go forward till IR beacon is perpendicular to robot
		//go to the rolling goals and score in the highest goal
		//pick up rolling goal
		//turn toward IR beacon
		//score one ball in the center goal
		//place rolling goal in the parking zone
		//get other rolling goals if time
////////////////////////////////////////////////////////////////////////////////////////////////////


task main()
{

	writeDebugStreamLine("initalizing");
	initializeRobot();
	writeDebugStreamLine("initalized");
	#ifdef COMPETITION
		waitForStart();
  #else
	while (nNxtButtonPressed != kEnterButton){}
	#endif
	rotateDegrees(45);
	while (nNxtButtonPressed != kRightButton){}
	rotateDegrees(45);
	while (nNxtButtonPressed != kRightButton){}


if (TestHook == 1) {
	setPosition(tas, POS_AT_60CM, DEFAULT_DISTANCE-1.5);
	while (nNxtButtonPressed != kRightButton){}
	hookGrab();
	wait1Msec(3000);
	moveInches(-20);
	hookUngrab();
	while (nNxtButtonPressed != kLeftButton){}
}
if (TestHardware == 1) {
		writeDebugStreamLine("Test Hardware");
	trapDoorOpen();
	trapDoorClose();
		servo[collector] = COLLECTOR_IDLE;
 	setPosition (tas, POS_BALL_COLLECTING, DEFAULT_DISTANCE);
wait10Msec(300);
		servo[collector] = COLLECTOR_IN;
wait10Msec(300);
		servo[collector] = COLLECTOR_IDLE;
	setPosition(tas, POS_AT_60CM, DEFAULT_DISTANCE-1.5);
  wait10Msec(1000);
	trapDoorOpen();
 wait10Msec(3000);
}
if (TestPositions == 1) {
		writeDebugStreamLine("Test Positions");
	//	while (nNxtButtonPressed != kRightButton){}
	//setPosition (tas, POS_DRIVE, DEFAULT_DISTANCE);
	//	while (nNxtButtonPressed != kLeftButton){}
 //	setPosition (tas, POS_AT_60CM, DEFAULT_DISTANCE);
	//	while (nNxtButtonPressed != kRightButton){}

		//Test 90
	//setPosition (tas, POS_DRIVE, DEFAULT_DISTANCE);
	//	while (nNxtButtonPressed != kLeftButton){}
 //	setPosition (tas, POS_AT_90CM, DEFAULT_DISTANCE);
	//	while (nNxtButtonPressed != kRightButton){}
	//		trapDoorOpen();
	//	while (nNxtButtonPressed != kEnterButton){}

			setPosition (tas, POS_DRIVE, DEFAULT_DISTANCE);
		while (nNxtButtonPressed != kLeftButton){}
 			setPosition (tas, POS_AT_120CM, DEFAULT_DISTANCE);
		while(nNxtButtonPressed != kEnterButton){}
			moveInches(24);
		while (nNxtButtonPressed != kRightButton){}
			trapDoorOpen();
		while(nNxtButtonPressed != kEnterButton){}
			moveInches(-24);
		while (nNxtButtonPressed != kLeftButton){}
	setPosition (tas, POS_DRIVE, DEFAULT_DISTANCE);

		while (nNxtButtonPressed != kEnterButton){}
 	setPosition (tas, POS_AT_120CM, DEFAULT_DISTANCE);
		while (nNxtButtonPressed != kRightButton){}
	setPosition (tas, POS_DRIVE, DEFAULT_DISTANCE);
		while (nNxtButtonPressed != kLeftButton){}
	setPosition (tas, POS_AT_90CM, DEFAULT_DISTANCE+3.5);
		while (nNxtButtonPressed != kRightButton){}
	setPosition (tas, POS_DRIVE, DEFAULT_DISTANCE);
		while (nNxtButtonPressed != kLeftButton){}
	setPosition (tas, POS_AT_120CM, DEFAULT_DISTANCE);
		while (nNxtButtonPressed != kRightButton){}
	trapDoorOpen();
		while (nNxtButtonPressed != kRightButton){}
	setPosition (tas, POS_AT_30CM, DEFAULT_DISTANCE);
		while (nNxtButtonPressed != kLeftButton){}
	//setPosition (tas, POS_DRIVE, DEFAULT_DISTANCE);
		//while (nNxtButtonPressed != kRightButton){}
	setPosition (tas, POS_AT_90CM, DEFAULT_DISTANCE);
		while (nNxtButtonPressed != kEnterButton){}
	setPosition (tas, POS_DRIVE, DEFAULT_DISTANCE);
		while (nNxtButtonPressed != kRightButton){}
	setPosition (tas, POS_AT_120CM, DEFAULT_DISTANCE);
		//while (nNxtButtonPressed != kLeftButton){}
	setPosition (tas, POS_DRIVE, DEFAULT_DISTANCE);
		while (nNxtButtonPressed != kEnterButton){}

}
#if 0
	setPosition (tas, POS_DRIVE, DEFAULT_DISTANCE);
	wait10Msec(200); //wait 2 sec for raise
	//moveInches(50);
	moveInches(54);
	setPosition(tas, POS_AT_60CM, DEFAULT_DISTANCE-1.5);
  wait10Msec(1000);
	//moveInches(14);
	moveInches(10);
	trapDoorOpen();
	wait10Msec(500);
	moveInches(-20);
	setPosition (tas, POS_DRIVE, DEFAULT_DISTANCE);
	wait10Msec(2000);
#endif
}
