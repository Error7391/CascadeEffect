#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     colorPort,      sensorCOLORFULL)
#pragma config(Sensor, S4,     irSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     motorL,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorR,        tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Motor,  motorB,          motorL,     tmotorNXT, openLoop, encoder)
//#pragma config(Motor,  motorC,          motorR,    tmotorNXT, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//#define NXT

#define RIGHT  1
#define LEFT 0
int side = LEFT;
//Function declarations
void colorFind();
void findBeacon();

TFileHandle hFileHandle;
TFileIOResult nIoResult;
char sOutput[100];

task main()
{
	string sFileName = "debug.txt";
	int nFileSize =10000;

	nPidUpdateInterval = 20;

	wait1Msec(10);

	eraseDisplay();
	nxtDisplayTextLine(0, "Autonomous Period");

	Delete(sFileName,nIoResult);
	OpenWrite(hFileHandle, nIoResult, sFileName, nFileSize);
	WriteText(hFileHandle, nIoResult, "Autonomous Period\n");
	nMotorEncoder[motorR] = 0;
	nMotorEncoder[motorL] = 0;
	//If it is using motor left, then side is equal to right
	if (side == RIGHT)
	{
		motor[motorL] = 100;
		while (nMotorEncoder[motorL] < 400){

		}
		motor[motorL] = 0;
	}
	else if (side == LEFT)
	{
		motor[motorR] = 100;
		while (nMotorEncoder[motorR] < 90){

		}
		motor[motorR] = 0;
	}
	////until (value of lightSensor = (blue/red))
	////go forward
	////end until

	//findColor();
	findBeacon();

	//until (distance from irSeeker = (something))
	//go forward
	//end until
	Close(hFileHandle, nIoResult);
}

void findColor()
{

	word nAtoDValue;
	word nRawValue;
	word nColorValue;
	string sTemp;
	int nRed, nGreen, nBlue;
	//change color to correspond to team color
	bool bBlueFound = false;
	int color1, color2;

	while (false == bBlueFound){

		motor[motorR] = 20;
		motor[motorL] = 20;
		color1 = SensorValue(colorPort);

		if (BLUECOLOR == color1){
			wait1Msec(5);
			color2 = SensorValue(colorPort);
			if (BLUECOLOR == color2){
				bBlueFound = true;
			}
		}
		nAtoDValue    = 0;
		nRawValue     = SensorRaw[colorPort];

		nxtDisplayTextLine(4, "raw:%d color1%d color2%d", nRawValue, color1, color2);
		//getColorSensorData(colorPort, colorRaw,    &nRawValues[0]);
		sprintf(sOutput, "raw:%d color1%d color2%d\n", nRawValue, color1, color2);
		WriteText(hFileHandle, nIoResult, sOutput);
	}

	motor[motorR] = 0;
	motor[motorL] = 0;
	//until (value of irSeeker = (9/0))
	//line followright)
	//end until
	nMotorEncoder[motorR] = 0;
	nMotorEncoder[motorL] = 0;
	motor[motorR] = 100;
	while (nMotorEncoder[motorR] < 90){

	}
}
void findBeacon()
{
	int irValue = 0;
	motor[motorR] = 0;
	while (SensorValue(irSeeker) != 8){
		motor[motorR] = 30;
		motor[motorL] = 30;
		irValue = SensorValue(irSeeker);

		nxtDisplayTextLine(4, "irValue%d", irValue);
		//getColorSensorData(colorPort, colorRaw,    &nRawValues[0]);
		sprintf(sOutput, "irValue%d\n", irValue);
		WriteText(hFileHandle, nIoResult, sOutput);
	}
	motor[motorR] = 0 ;
	motor[motorL] = 0 ;
	//until (value of irSeeker = (5))
	//turn right
	//end until
	//if motor left is used then side is eu
	while (SensorValue(irSeeker) != 5){
		motor[motorR] = -30;
		motor[motorL] = 30;
		irValue  = SensorValue(irSeeker);
		nxtDisplayTextLine(4, "irValue%d", irValue);
		sprintf(sOutput, "irValue%d\n", irValue);
		WriteText(hFileHandle, nIoResult, sOutput);
	}
	nMotorEncoder[motorR] = 0;
	nMotorEncoder[motorL] = 0;
	motor[motorR] = 30;
	motor[motorL] = 30;
	while (nmotorEncoder[motorR] < 500){

	}
	motor[motorR] = 0;
	motor[motorL] = 0;
}
