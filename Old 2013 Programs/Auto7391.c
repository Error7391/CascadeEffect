#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S2,     colorR,         sensorCOLORFULL)
#pragma config(Sensor, S3,     colorL,         sensorCOLORFULL)
#pragma config(Sensor, S4,     irSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorB,          grabL,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          grabR,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorL,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorR,        tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Motor,  motorB,          motorL,     tmotorNXT, openLoop, encoder)
//#pragma config(Motor,  motorC,          motorR,    tmotorNXT, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//#define NXT

#define RIGHT  1
#define LEFT 0

#define DRIVE_DIAMETER 3

int side = LEFT;
//Function declarations
void findColor();
void findBeacon();
void moveInches(float distance, int speed );
void ungrab();

TFileHandle hFileHandle;
TFileIOResult nIoResult;
char sOutput[100];

task main()
{
	string sFileName = "debug.txt";
	int nFileSize =10000;

	nPidUpdateInterval = 20;

	wait1Msec(10);

	eraseDisplay();
	nxtDisplayTextLine(0, "Autonomous Period");

	Delete(sFileName,nIoResult);
	OpenWrite(hFileHandle, nIoResult, sFileName, nFileSize);
	WriteText(hFileHandle, nIoResult, "Autonomous Period\n");

	nMotorEncoder[motorR] = 0;
	nMotorEncoder[motorL] = 0;

	//turn right from wall
		//motor[motorL] = 50;
		//while (nMotorEncoder[motorL] < 1000){}
		//motor[motorL] = 0;

	moveInches(26,30);

	ungrab();

	moveInches(-3,30);

	//pivot back left 90deg
		nMotorEncoder[motorR] = 0;
	nMotorEncoder[motorL] = 0;
			motor[motorL] = -50;
		while (nMotorEncoder[motorL] > -2400){}
		motor[motorL] = 0;

			findColor();

	//ratate back left 90deg
		nMotorEncoder[motorR] = 0;
	nMotorEncoder[motorL] = 0;
		motor[motorL] = -50;
		motor[motorR] = 50;
		while (nMotorEncoder[motorR] < 1200){}
		motor[motorL] = 0;
		motor[motorR] = 0;

	//go up the ramp
		moveInches(-30, 100);


#if 0
	//If it is using motor left, then side is equal to right
	if (side == RIGHT)
	{
		motor[motorL] = 100;
		while (nMotorEncoder[motorL] < 400){

		}
		motor[motorL] = 0;
	}
	else if (side == LEFT)
	{
		motor[motorR] = 100;
		while (nMotorEncoder[motorR] < 90){

		}
		motor[motorR] = 0;
	}
	////until (value of lightSensor = (blue/red))
	////go forward
	////end until

	//findColor();
	findBeacon();
#endif
	//until (distance from irSeeker = (something))
	//go forward
	//end until
	Close(hFileHandle, nIoResult);
}

void findColor()
{

	word nAtoDValue;
	word nRawValue;
	word nColorValue;
	string sTemp;
	int nRed, nGreen, nBlue;
	//change color to correspond to team color
	bool bBlueFound = false;
	int color1, color2;

	while (false == bBlueFound){

		motor[motorR] = 30;
		motor[motorL] = 30;
		color1 = SensorValue(colorR);

		if (BLUECOLOR == color1){
			wait1Msec(5);
			color2 = SensorValue(colorR);
			if (BLUECOLOR == color2){
				bBlueFound = true;
			}
		}
		nAtoDValue    = 0;
		nRawValue     = SensorRaw[colorR];

		nxtDisplayTextLine(4, "raw:%d color1%d color2%d", nRawValue, color1, color2);
		//getColorSensorData(colorPort, colorRaw,    &nRawValues[0]);
		sprintf(sOutput, "raw:%d color1%d color2%d\n", nRawValue, color1, color2);
		WriteText(hFileHandle, nIoResult, sOutput);
	}

	motor[motorR] = 0;
	motor[motorL] = 0;
	//until (value of irSeeker = (9/0))
	//line followright)
	//end until
	//nMotorEncoder[motorR] = 0;
	//nMotorEncoder[motorL] = 0;
	//motor[motorR] = 100;
	//while (nMotorEncoder[motorR] < 90){

	}

void findBeacon()
{
	int irValue = 0;
	motor[motorR] = 0;
	while (SensorValue(irSeeker) != 8){
		motor[motorR] = 30;
		motor[motorL] = 30;
		irValue = SensorValue(irSeeker);

		nxtDisplayTextLine(4, "irValue%d", irValue);
		//getColorSensorData(colorPort, colorRaw,    &nRawValues[0]);
		sprintf(sOutput, "irValue%d\n", irValue);
		WriteText(hFileHandle, nIoResult, sOutput);
	}
	motor[motorR] = 0 ;
	motor[motorL] = 0 ;
	//until (value of irSeeker = (5))
	//turn right
	//end until
	//if motor left is used then side is eu
	while (SensorValue(irSeeker) != 5){
		motor[motorR] = -30;
		motor[motorL] = 30;
		irValue  = SensorValue(irSeeker);
		nxtDisplayTextLine(4, "irValue%d", irValue);
		sprintf(sOutput, "irValue%d\n", irValue);
		WriteText(hFileHandle, nIoResult, sOutput);
	}
	nMotorEncoder[motorR] = 0;
	nMotorEncoder[motorL] = 0;
	motor[motorR] = 30;
	motor[motorL] = 30;
	while (nmotorEncoder[motorR] < 500){

	}
	motor[motorR] = 0;
	motor[motorL] = 0;

}

void moveInches(float distance, int speed )
{
	float ticks = 1440/(DRIVE_DIAMETER*PI)*distance;

	nMotorEncoder[motorR] = 0;
		nMotorEncoder[motorL] = 0;
		nMotorEncoderTarget[motorR] = ticks;
		nMotorEncoderTarget[motorL] = ticks;

		if(distance > 0){
			motor[motorR] = speed;
		motor[motorL] = speed;
	}
	else{
			motor[motorR] = -speed;
		motor[motorL] = -speed;
	}

	while(nMotorRunState[motorR] != runStateIdle)
	{

	}
	motor[motorR] = 0;
	motor[motorL] = 0;
}
//ungrab the block
void ungrab()
{
	nMotorEncoder[grabR] = 0;
	while(nMotorEncoder[grabR] > -1000)
	{
	motor[grabR] = -100;
	motor[grabL] = -100;
	}
	motor[grabR] = 0;
	motor[grabL] = 0;
}
